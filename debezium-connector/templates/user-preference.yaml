{{- if .Values.userPreferenceService.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-user-preference-connector-config
  namespace: {{ .Values.userPreferenceService.namespace }}
data:
  connector-config.json: |
    {
      "name": "user-preference-{{ .Values.base.name }}",
      "config": {
        "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
        "tasks.max": "1",
        "database.hostname": "{{ .Values.userPreferenceService.database.hostname }}",
        "database.port": "{{ .Values.userPreferenceService.database.port }}",
        "database.user": "{{ .Values.userPreferenceService.database.username }}",
        "database.password": "@DATABASE_PASSWORD@",
        "database.dbname": "{{ .Values.userPreferenceService.database.dbname }}",
        "database.server.name": "user-preference-db",
        "table.include.list": "core.message",
        "topic.prefix": "user-preference",
        "plugin.name": "pgoutput",
        "slot.name": "debezium_user-preference_slot",
        "publication.name": "debezium_user-preference_publication",
        "key.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter": "org.apache.kafka.connect.json.JsonConverter",
        "key.converter.schemas.enable": "true",
        "value.converter.schemas.enable": "true",
        "transforms": "messaging",
        "transforms.messaging.type": "org.cresplanex.core.cdc.debezium.TransactionalMessaging"
      }
    }
  init.sql: |
    CREATE DATABASE {{ .Values.userPreferenceService.database.dbname }};
    GRANT ALL PRIVILEGES ON DATABASE {{ .Values.userPreferenceService.database.dbname }} TO {{ .Values.userPreferenceService.database.username }};

    \c {{ .Values.userPreferenceService.database.dbname }}

    CREATE SCHEMA core;

    DROP TABLE IF EXISTS core.events CASCADE;
    DROP TABLE IF EXISTS core.entities CASCADE;
    DROP TABLE IF EXISTS core.snapshots CASCADE;
    DROP TABLE IF EXISTS core.cdc_monitoring CASCADE;

    CREATE TABLE core.events (
      event_id VARCHAR(1000) PRIMARY KEY,
      event_type VARCHAR(1000),
      event_data VARCHAR(1000) NOT NULL,
      entity_type VARCHAR(1000) NOT NULL,
      entity_id VARCHAR(1000) NOT NULL,
      triggering_event VARCHAR(1000),
      metadata VARCHAR(1000),
      published SMALLINT DEFAULT 0
    );

    CREATE INDEX events_idx ON core.events(entity_type, entity_id, event_id);
    CREATE INDEX events_published_idx ON core.events(published, event_id);

    CREATE TABLE core.entities (
      entity_type VARCHAR(1000),
      entity_id VARCHAR(1000),
      entity_version VARCHAR(1000) NOT NULL,
      PRIMARY KEY(entity_type, entity_id)
    );

    CREATE INDEX entities_idx ON core.entities(entity_type, entity_id);

    CREATE TABLE core.snapshots (
      entity_type VARCHAR(1000),
      entity_id VARCHAR(1000),
      entity_version VARCHAR(1000),
      snapshot_type VARCHAR(1000) NOT NULL,
      snapshot_json VARCHAR(1000) NOT NULL,
      triggering_events VARCHAR(1000),
      PRIMARY KEY(entity_type, entity_id, entity_version)
    );

    CREATE TABLE core.cdc_monitoring (
      reader_id VARCHAR(1000) PRIMARY KEY,
      last_time BIGINT
    );

    DROP TABLE IF EXISTS core.message CASCADE;
    DROP TABLE IF EXISTS core.received_messages CASCADE;

    CREATE TABLE core.message (
      id VARCHAR(1000) PRIMARY KEY,
      destination TEXT NOT NULL,
      headers TEXT NOT NULL,
      payload TEXT NOT NULL,
      published SMALLINT DEFAULT 0,
      message_partition SMALLINT,
      creation_time BIGINT
    );

    CREATE INDEX message_published_idx ON core.message(published, id);

    CREATE TABLE core.received_messages (
      consumer_id VARCHAR(1000),
      message_id VARCHAR(1000),
      creation_time BIGINT,
      published SMALLINT DEFAULT 0,
      PRIMARY KEY(consumer_id, message_id)
    );

    CREATE TABLE core.offset_store(
      client_name VARCHAR(255) NOT NULL PRIMARY KEY,
      serialized_offset VARCHAR(255)
    );

    SELECT * FROM pg_create_logical_replication_slot('core_slot', 'wal2json');
    SELECT * FROM pg_create_logical_replication_slot('core_slot2', 'wal2json');

    ALTER TABLE core.message DROP COLUMN payload;
    ALTER TABLE core.message ADD COLUMN payload JSON;

    ALTER TABLE core.message DROP COLUMN headers;
    ALTER TABLE core.message ADD COLUMN headers JSON;

    DROP Table IF Exists core.saga_instance_participants;
    DROP Table IF Exists core.saga_instance;
    DROP Table IF Exists core.saga_lock_table;
    DROP Table IF Exists core.saga_stash_table;

    CREATE TABLE core.saga_instance_participants (
      saga_type VARCHAR(512) NOT NULL,
      saga_id VARCHAR(100) NOT NULL,
      destination VARCHAR(512) NOT NULL,
      resource VARCHAR(512) NOT NULL,
      PRIMARY KEY(saga_type, saga_id, destination, resource)
    );

    CREATE TABLE core.saga_instance(
      saga_type VARCHAR(512) NOT NULL,
      saga_id VARCHAR(100) NOT NULL,
      state_name VARCHAR(100) NOT NULL,
      last_request_id VARCHAR(100),
      end_state BOOLEAN,
      compensating BOOLEAN,
      failed BOOLEAN,
      saga_data_type VARCHAR(1024) NOT NULL,
      saga_data_json TEXT NOT NULL,
      PRIMARY KEY(saga_type, saga_id)
    );

    create table core.saga_lock_table(
      target VARCHAR(512) PRIMARY KEY,
      saga_type VARCHAR(512) NOT NULL,
      saga_Id VARCHAR(100) NOT NULL
    );

    create table core.saga_stash_table(
      message_id VARCHAR(100) PRIMARY KEY,
      target VARCHAR(512) NOT NULL,
      saga_type VARCHAR(512) NOT NULL,
      saga_id VARCHAR(100) NOT NULL,
      message_headers TEXT NOT NULL,
      message_payload TEXT NOT NULL
      );
---

apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Release.Name }}-user-preference-register-connector
  namespace: {{ .Values.userPreferenceService.namespace }}
  labels:
    sidecar.istio.io/inject: "false"
spec:
  template:
    metadata:
      labels:
        sidecar.istio.io/inject: "false"
      annotations:
        sidecar.istio.io/inject: "false"
    spec:
      initContainers:
        - name: wait-for-postgres
          image: postgres
          env:
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ .Values.userPreferenceService.database.passwordSecrets }}
                  key: {{ .Values.userPreferenceService.database.passwordSecretKey }}
          command:
            - sh
            - -c
            - |
              echo "Waiting for PostgreSQL to be ready..."
              until psql -h {{ .Values.userPreferenceService.database.hostname }} -U {{ .Values.userPreferenceService.database.username }} -c "SELECT 1;" > /dev/null 2>&1; do
                echo "PostgreSQL is not ready. Retrying in 5 seconds..."
                sleep 5
              done
              echo "PostgreSQL is ready."
      containers:
        - name: register-connector
          image: bitnami/minideb:latest
          serviceAccountName: {{ .Values.userPreferenceService.serviceAccount }}
          command:
            - sh
            - -c
            - |
              apt-get update && apt-get install -y postgresql-client curl jq && \
              echo "Initializing database" && \
              psql -h {{ .Values.userPreferenceService.database.hostname }} -U {{ .Values.userPreferenceService.database.username }} -f /app_scripts/init.sql && \
              echo "Replacing database password in connector config" && \
              REPLACE_PASSWORD=$(sed "s/@DATABASE_PASSWORD@/$PGPASSWORD/g" /app_scripts/connector-config.json) && \
              echo "Registering connector" && \
              curl -X POST -H "Content-Type: application/json" \
              --data "$REPLACE_PASSWORD" \
              http://{{ .Values.base.connector.connectHost }}:{{ .Values.base.connector.connectPort }}/connectors && \
              exit 0
          volumeMounts:
            - name: connector-config
              mountPath: /app_scripts
          env:
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ .Values.userPreferenceService.database.passwordSecrets }}
                  key: {{ .Values.userPreferenceService.database.passwordSecretKey }}
      volumes:
        - name: connector-config
          configMap:
            name: {{ .Release.Name }}-user-preference-connector-config
      restartPolicy: OnFailure
{{- end }}